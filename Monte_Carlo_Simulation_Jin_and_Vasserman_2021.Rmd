---
title: 'Monte Carlo Simulation: Jin and Vasserman (2021)'
author: "Yuki KAYABA"
date: "3/24/2023"
site: bookdown::bookdown_site
output:
  bookdown::gitbook: default
#output_dir: docs
#bookdown::gitbook: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, eval = FALSE, cache = TRUE)
library(bookdown)
library(magrittr)
library(tidyverse)
library(MASS)
```

# Generate Data for Choice Model

## メモ
- $v_{idt} = \mathbb{E}[h_{idt}] -\frac{\gamma}{2}\mathbb{E}[h_{idt}^{2}]$の第2項は無視している

First we generate data in the following procedure.

1. Generate $\lambda_{imt}$. $\lambda_{imt}$ is one of the most significant variables that represents consumer's risk (observable for consumers but not econometrician)
2. Generate choice in $t = 0$ according to the choice model. In $t = 0$, consumers have four options: the firm with and without monitoring, competitor 1 and 2.
3. Generate realization of cost (claims count, severity and monitoring score) in $t = 0$ according to the cost model. 

## Generate $\lambda$

- The rate parameter, $\lambda_{imt}$ of Poisson distributed claims count, has mean $\mu_{\lambda, imt}$ and an additive error $\varepsilon_{\lambda, i}$ which is log-normally distributied with spread $\sigma_{\lambda}$
- We assume that $\mu_{\lambda, imt} = \theta_{\lambda1}x_{1, imt} + \cdots + \theta_{\lambda4}x_{4, imt}$ 

```{r generate lambda}
rm(list = ls())

N <- 10^3
T <- 1
D <- 4

# set the seed
set.seed(1)

## True Parameters
sigma_lambda <- 0.1
theta_lambda <- c(-3, -0.5, 1, -1, 1, -0.5)

## Covariates
mu_x_t0 <- rep(0, 4)
mu_x_t1 <- rep(0, 4)
sigma_x <- diag(0.25, 4)

X_t0 <- mvrnorm(N, mu_x_t0, sigma_x)
X_t1 <- 0.5*X_t0 + 0.5*mvrnorm(N, mu_x_t1, sigma_x)

X <- X_t0 %>% 
  rbind(X_t0) %>% 
  rbind(X_t1) %>% 
  rbind(X_t1)

colnames(X) <- c(paste("x", 1:4, sep = "_"))

X_lambda <- expand.grid(i = 1:N, m = 0:1, t = 0:1) %>% 
  tibble::as_tibble() %>% 
  cbind(X)

## mu_lambda
mu_lambda <- X_lambda %>% 
  dplyr::mutate(mu_lambda = theta_lambda[1]
                + theta_lambda[2]*x_1 + theta_lambda[3]*x_2
                + theta_lambda[4]*x_3 + theta_lambda[5]*x_4
                + theta_lambda[6]*ifelse(m == 1 & t == 0, 1, 0))

## epsilon_lambda
epsilon_lambda <- expand.grid(i = 1:N) %>% 
  tibble::as_tibble() %>% 
  dplyr::mutate(epsilon_lambda = rnorm(N, 0, sigma_lambda))

## lambda
lambda <- mu_lambda %>% 
  dplyr::left_join(epsilon_lambda, by = c("i")) %>% 
  dplyr::mutate(lambda = exp(mu_lambda + epsilon_lambda))

```

- The distribution of generated $\lambda$ is as follows

```{r visualize lambda}
## Visualize 
g_lambda <- lambda %>% 
  ggplot(aes(x = lambda)) + 
  geom_histogram(binwidth = 0.01)

plot(g_lambda)
```

- We also check opt-in drivers tend to have lower risk

```{r visualize lambda and monitoring opt-in}
## Visualize lambda and monitoring opt-in
g_lambda_monitoring <- lambda %>% 
  dplyr::mutate(monitoring = ifelse(m == 1, "Monitored", "Unmonitored")) %>% 
  ggplot(aes(x = monitoring, y = lambda)) + 
  geom_boxplot() + 
  scale_y_continuous(limits=c(0, 0.1))

plot(g_lambda_monitoring)
```

## Generate (Expectation of) Monitoring Score and Out-of-Pocket

- Then, we generate expectation of monitoring score and severity, which is necessary for expectation of out-of-pocket, $e(C, y_{d})$ and renewal price multiplier $R_{idt}(C, s)$.
- Score $s$ follows log-normal distribution with an individual mean $\mu_{s, i}$ and precision $\sigma_{s}$
- Assuming that $\mu_{s, i} = \theta_{s, 1} + \theta_{s, 2}\log(\lambda_{i}) + \theta_{s, 3}x_{1, i} + \theta_{s, 4}x_{2, i}$, the expectation of score is given by $\exp(\mu_{s, i} + \frac{\sigma_{s}^{2}}{2})$
- Out-of-pocket (OOP), is that consumers have to pay when an accident occurs due to deductible and/or policy limit
- We assume that every plan has only policy limit
- In the paper, for simplicity, consumers only consider the possibility of one claim occurrence per term in expectation
- Then, expectation of OOP is given by:

$$
\begin{align}
E[e(C, y_{d})] &= \Pr(C = 1) \times \int_{y_{0}}^{\infty} (x - y_{0})a_{l} l_{0}^{a_{l}} x^{- a_{l} - 1}dx \\
&=  \lambda \exp(-\lambda) \times \left\{ \frac{l_{0}^{a_{l}}}{a_{l} - 1} y_{0}^{-a_{l} + 1} \right\}
\end{align}
$$

```{r expectation of score}
## Generate expectations of score
theta_score <- c(-3, -0.5, 2, 1)
sigma_score <- 0.25

score <- lambda %>% 
  dplyr::filter(t == 0, m == 1) %>% 
  dplyr::mutate(mu_score = theta_score[1] + theta_score[2]*log(lambda)
                + theta_score[3]*x_1 + theta_score[4]*x_2,
                E_score = exp(mu_score + sigma_score^2 / 2)) %>% 
  dplyr::select(i, m, t, mu_score, E_score)

## Visualize Score
g_mu_score <- score %>% 
  ggplot(aes(x = mu_score)) + 
  geom_histogram(binwidth = 0.1)

plot(g_mu_score)
```

```{r expectation of oop}
## Expectation of Out-of-Pocket
policy_limit <- 1000
l0 <- 500
a_l <- 2.5

E_oop <- lambda %>% 
  dplyr::mutate(prob_C1 = lambda * exp(-lambda),
                E_oop = prob_C1 * (l0^(a_l)/(a_l - 1))*policy_limit^(-a_l + 1),
                E_oop_sq = prob_C1 * ((2 * l0^(a_l)) / ((a_l - 1) * (a_l - 1))) * policy_limit^(-a_l + 2)) %>% 
  dplyr::select(i, m, t, E_oop, E_oop_sq)

## Visualize OOP
g_oop <- E_oop %>% 
  ggplot(aes(x = E_oop)) + 
  geom_histogram(binwidth = 0.5)

plot(g_oop)

```

## Generate Choice in $t = 0$

- In the paper, consumer's realized choice utility is modeled as follows: 

$$
\begin{align}
u_{idt}(C, s) &= u_{\gamma}(w_{it} + h_{idt}(C, s)) \\
h_{idt}(C, s) &= -p_{idt} - \mathbf{1}_{d, t-1} \cdot \psi_{idt} - e(C, y_{d}) - p_{idt} \cdot R_{idt}(C, s) \\
\text{where } \psi_{idt} &= \mathbf{1}_{d, t-1} \cdot \eta_{0} + \mathbf{1}_{f_{d}, t-1} \cdot \eta_{it} + \mathbf{1}_{m_{d}} \cdot \mathbf{1}_{t=0} \cdot \xi_{it}
\end{align}
$$

- At each period $t$, consumer $i$ chooses $d$ so as to maximize her expected utility:

$$
\begin{align}
d_{it} &= \mathop{\rm argmax}\limits_{d \in D_{it}} \left\{ v_{idt} + \varepsilon_{idt} \right\} \\
\text{where } v_{idt} &= \mathbb{E}_{C, s}[u_{idt}(C, s)] = \mathbb{E}[h_{idt}] -\frac{\gamma}{2}\mathbb{E}[h_{idt}^{2}]
\end{align}
$$

- Thus, we start with generating each component of $h_{idt}$.

```{r generate choice in t0}

price_par_t0_d1 <- c(15, 3, 2, 3, -2)
price_par_t0_d2 <- c(15, 3, 2, 3, -2)
price_par_t0_d3 <- c(15, 1, 3, 2, -2)
price_par_t0_d4 <- c(15, 4, 5, 1, -2)

price_gen_d <- function(choice_t0, D, price_par_t0){
  output <- choice_t0 %>% 
    dplyr::filter(d == D) %>% 
    dplyr::mutate(price = 
                    price_par_t0[1] +
                    price_par_t0[2]*x_1 + 
                    price_par_t0[3]*x_2 + 
                    price_par_t0[4]*x_3 +
                    price_par_t0[5]*m +
                    rnorm(N, 1, 1)) %>% 
    dplyr::select(i, d, t, m, f, price)
}

## Generate Price
price_gen_t0 <- function(choice_t0,
                         price_par_t0_d1, price_par_t0_d2,
                         price_par_t0_d3, price_par_t0_d4){
  
  price <- price_gen_d(choice_t0, 1, price_par_t0_d1) %>% 
    rbind(price_gen_d(choice_t0, 2, price_par_t0_d2)) %>% 
    rbind(price_gen_d(choice_t0, 3, price_par_t0_d3)) %>% 
    rbind(price_gen_d(choice_t0, 4, price_par_t0_d4))
  
  output <- choice_t0 %>% 
    dplyr::left_join(price, by = c("i", "d", "t", "m", "f"))
  
  return(output) 
}

## Generate Prior Firm

prior_firm_t0 <- expand.grid(i = 1:N) %>% 
  tibble::as_tibble() %>% 
  dplyr::mutate(prior_firm = sample(1:4, size = N, replace = T, prob = c(0, 0.4, 0.35, 0.25)))


## True Parameters
### Inertia

eta_f <- c(5, 1, 2, 2)
xi <- c(1, -2.5)

### Renewal Price
alpha_m0 <- c(20, 5, 3)
alpha_m1 <- c(20, 5, 3, -1)
beta <- 20

### Risk Aversion
risk_aversion <- 10^(-4)

## Generate Choice

choice_t0 <- expand.grid(i = 1:N, d = 1:D, t = 0) %>% 
  tibble::as_tibble() %>% 
  dplyr::mutate(m = ifelse(d == 1, 1, 0),
                f = dplyr::case_when(
                  d <= 2 ~ 1,
                  d == 3 ~ 2,
                  d == 4 ~ 3)) %>% 
  dplyr::left_join(lambda, by = c("i", "m", "t")) %>% 
  dplyr::left_join(score, by = c("i", "m", "t")) %>% 
  dplyr::left_join(E_oop, by = c("i", "m", "t")) %>% 
  price_gen_t0(price_par_t0_d1, price_par_t0_d2, price_par_t0_d3, price_par_t0_d4) %>% 
  dplyr::left_join(prior_firm_t0, by = c("i")) %>% 
  dplyr::mutate(inertia = eta_f[1] + eta_f[2]*x_1 + eta_f[3]*x_2 + eta_f[4]*x_3,
                monitoring_disutility = xi[1] + xi[2]*log(lambda),
                demand_friction = ifelse(d == prior_firm, 0, inertia) + 
                  ifelse(d == 1, monitoring_disutility, 0)) %>% 
  dplyr::mutate(E_R_s = ifelse(m == 0, 
                           (alpha_m0[1] + alpha_m0[2]*x_1 + alpha_m0[3]*x_2) / beta,
                           (alpha_m1[1] + alpha_m1[2]*x_1 + alpha_m1[3]*x_2 + alpha_m1[4]*E_score) / beta),
                E_R_s_sq = E_R_s / beta,
                E_R_C = 0.98 * exp(-lambda) + 1.2 * (1 - exp(-lambda)),
                E_R_C_sq = 0.98^2 * exp(-lambda) + 1.2^2 * (1 - exp(-lambda)),
                E_renewal_price = price * E_R_s * E_R_C,
                E_renewal_price_sq = price^2 * E_R_s_sq * E_R_C_sq) %>% 
  dplyr::mutate(h = - price - demand_friction - E_oop - E_renewal_price,
                h_sq = price^2 - demand_friction^2 + E_oop_sq + E_renewal_price_sq
                + 2*price*demand_friction + 2*price*E_oop + 2*price*E_renewal_price
                + 2*demand_friction*E_oop + 2*demand_friction*E_renewal_price
                + 2*E_oop*E_renewal_price)

# draw idiosyncratic shocks
e_t0 <- evd::rgev(dim(choice_t0)[1])

choice_t0 <- cbind(choice_t0, e_t0) %>% 
  dplyr::mutate(v = h - (risk_aversion / 2)*h_sq,
                u = v + e_t0) %>% 
  dplyr::group_by(i, t) %>% 
  dplyr::mutate(choice = ifelse(u == max(u), 1, 0)) %>% 
  dplyr::ungroup()

summary(choice_t0)

summarize_choice <- choice_t0 %>% 
  dplyr::group_by(d) %>% 
  dplyr::summarise(share = mean(choice))

summarize_choice
```

- The figure shows generated prices of each plan.
- Monitoring plan provided by firm 1 is slightly lower than other plans, representing the opt-in discount

```{r visualize price}
## Visualize Price in t = 0
g_price_t0 <- choice_t0 %>% 
  dplyr::mutate(plan = dplyr::case_when(d == 1 ~ "Firm1 Monitoring",
                                        d == 2 ~ "Firm1 No Monitoring",
                                        d == 3 ~ "Firm2",
                                        d == 4 ~ "Firm3")) %>% 
  ggplot(aes(x = price, fill = plan)) + 
  geom_histogram(position = "identity", alpha = 0.6, binwidth = 0.25)

plot(g_price_t0)

```

- The following figure shows the expectation of $R_{idt}(s)$, which implies that monitored consumers tend to have smaller expected renewal prices, incentivizing them to opt-in

```{r visualize E_R_s}
## Visualize E_R_s in t = 0
g_E_R_s_t0 <- choice_t0 %>% 
  dplyr::filter(f == 1) %>% 
  dplyr::mutate(plan = dplyr::case_when(m == 1 ~ "Monitoring",
                                        m == 0 ~ "No Monitoring")) %>% 
  ggplot(aes(x = E_R_s, fill = plan)) + 
  geom_histogram(position = "identity", alpha = 0.6, binwidth = 0.01)

plot(g_E_R_s_t0)

```

## Generate Realization of Cost in $t = 0$

- Since consumer's choice is path-dependent, i.e. price in next period depends on claims and monitoring score, we need to generate realization of costs in $t = 0$
- Claim occurs according to Poisson distribution with mean $\lambda$
- The monitoring score $s$ is drawn according to a log-normal distribution with mean $\mu_{s, i}$ and precision $\sigma_{s}$
- Note that we do not need to generate realization of severity since it does not affect consumer's choice in $t = 1$

```{r cost realization}
## Claims Count
cost_t0 <- choice_t0 %>% 
  dplyr::filter(choice == 1) %>% 
  dplyr::mutate(claims = rpois(N, lambda = lambda))

## Severity
# max_claims <- max(cost_t0$claims)
# 
# claims_mat <- matrix(rep(0, N * max_claims), nrow = N)
# severity <- matrix(l0*runif(N * max_claims)^(-1/a_l), nrow = N)
# 
# colnames(severity) <- paste("sev_", 1:max_claims, sep = "")
# 
# cost_t0 <- cbind(cost_t0, severity)

## Monitoring Score
cost_t0 <- cost_t0 %>% 
  dplyr::mutate(score = rlnorm(N, mu_score, sigma_score),
                score = ifelse(m == 1, score, 1),
                log_score = log(score)) %>% 
  dplyr::select(i, claims, matches("sev."), score, log_score)

```

```{r visualize realized claims count}
## Visualize realized claims count
g_realized_claims_count <- cost_t0 %>%
  ggplot(aes(x = claims)) + 
  geom_histogram(binwidth = 0.5)

plot(g_realized_claims_count)

```

- The following figure shows realized monitoring scores (in logarithm) for opt-in drivers

```{r visualize realized score}
## Visualize realized score
g_realized_score <- cost_t0 %>%
  dplyr::filter(score != 1) %>% 
  ggplot(aes(x = log_score)) + 
  geom_histogram(binwidth = 0.25)

plot(g_realized_score)

```

## Generate Choice in $t = 1$

```{r generate choice in t1}
## Prior Choice and Firm
prior_firm_t1 <- choice_t0 %>% 
  dplyr::filter(choice == 1) %>% 
  dplyr::mutate(prior_choice = d * choice,
                prior_firm = f * choice) %>% 
  dplyr::select(i, prior_choice, prior_firm)

### Prior Price
prior_price_t1 <- choice_t0 %>% 
  dplyr::left_join(prior_firm_t1, by = c("i")) %>% 
  dplyr::mutate(prior_price = price,
                flg = dplyr::case_when(prior_choice == 1 & d != 2 ~ 1,
                                       prior_choice > 1 & d != 1 ~ 1,
                                       TRUE ~ 0)) %>% 
  dplyr::filter(flg == 1) %>% 
  dplyr::select(i, f, prior_price) %>% 
  dplyr::arrange(i)

## Choice in t = 1
choice_t1 <- expand.grid(i = 1:N, d = 1:(D - 1), t = 1) %>% 
  tibble::as_tibble() %>% 
  dplyr::mutate(m = 0,
                f = d) %>% 
  dplyr::left_join(prior_firm_t1, by = c("i")) %>% 
  dplyr::left_join(prior_price_t1, by = c("i", "f")) %>% 
  dplyr::left_join(lambda, by = c("i", "m", "t")) %>% 
  dplyr::left_join(E_oop, by = c("i", "m", "t")) %>% 
  dplyr::left_join(cost_t0, by = c("i")) %>% 
  dplyr::mutate(gamma_alpha = ifelse(score == 1,
                                     alpha_m0[1] + alpha_m0[2]*x_1 + alpha_m0[3]*x_2,
                                     alpha_m1[1] + alpha_m1[2]*x_1 + alpha_m1[3]*x_2 + alpha_m1[4]*score)) %>% 
  dplyr::mutate(R_s = rgamma(N * (D - 1), gamma_alpha, beta),
                R_C = ifelse(claims == 0, 0.98, 1.2),
                price = prior_price * R_s * R_C) %>% 
  dplyr::mutate(inertia = eta_f[1] + eta_f[2]*x_1 + eta_f[3]*x_2 + eta_f[4]*x_3,
                demand_friction = ifelse(d == prior_firm, 0, inertia)) %>%   
  dplyr::mutate(E_R_s = ifelse(m == 0, 
                           (alpha_m0[1] + alpha_m0[2]*x_1 + alpha_m0[3]*x_2) / beta,
                           (alpha_m1[1] + alpha_m1[2]*x_1 + alpha_m1[3]*x_2 + alpha_m1[4]*E_score) / beta),
                E_R_s_sq = E_R_s / beta,
                E_R_C = 0.98 * exp(-lambda) + 1.2 * (1 - exp(-lambda)),
                E_R_C_sq = 0.98^2 * exp(-lambda) + 1.2^2 * (1 - exp(-lambda)),
                E_renewal_price = price * E_R_s * E_R_C,
                E_renewal_price_sq = price^2 * E_R_s_sq * E_R_C_sq) %>% 
  dplyr::mutate(h = - price - demand_friction - E_oop - E_renewal_price,
                h_sq = price^2 - demand_friction^2 + E_oop_sq + E_renewal_price_sq
                + 2*price*demand_friction + 2*price*E_oop + 2*price*E_renewal_price
                + 2*demand_friction*E_oop + 2*demand_friction*E_renewal_price
                + 2*E_oop*E_renewal_price) %>% 
  dplyr::arrange(i)

# draw idiosyncratic shocks
e_t1 <- evd::rgev(dim(choice_t1)[1])

choice_t1 <- cbind(choice_t1, e_t1) %>% 
  dplyr::mutate(v = h - (risk_aversion / 2)*h_sq,
                u = v + e_t1) %>% 
  dplyr::group_by(i, t) %>% 
  dplyr::mutate(choice = ifelse(u == max(u), 1, 0)) %>% 
  dplyr::ungroup()

summary(choice_t1)

summarize_choice_t1 <- choice_t1 %>% 
  dplyr::group_by(d) %>% 
  dplyr::summarise(share = mean(choice))

summarize_choice_t1
```
```{r visualize price in period 1}
## Visualize Price in t = 1
g_price_t1 <- choice_t1 %>% 
  dplyr::mutate(plan = dplyr::case_when(d == 1 ~ "Firm1",
                                        d == 2 ~ "Firm2",
                                        d == 3 ~ "Firm3"),
                prior_plan = dplyr::case_when(prior_choice == 1 ~ "Firm1 Monitoring",
                                              prior_choice == 2 ~ "Firm1 No Monitoring",
                                              prior_choice == 3 ~ "Firm2",
                                              prior_choice == 4 ~ "Firm3")) %>% 
  ggplot(aes(x = price, fill = prior_plan)) + 
  geom_histogram(position = "identity", alpha = 0.6, binwidth = 0.25)

plot(g_price_t1)

```

```{r visualize realized R_s in period 1}
## Visualize Realized R_s in t = 1
g_R_s_t1 <- choice_t1 %>% 
  dplyr::mutate(plan = dplyr::case_when(d == 1 ~ "Firm1",
                                        d == 2 ~ "Firm2",
                                        d == 3 ~ "Firm3"),
                prior_plan = dplyr::case_when(prior_choice == 1 ~ "Firm1 Monitoring",
                                              prior_choice == 2 ~ "Firm1 No Monitoring",
                                              prior_choice == 3 ~ "Firm2",
                                              prior_choice == 4 ~ "Firm3")) %>% 
  ggplot(aes(x = R_s, fill = prior_plan)) + 
  geom_histogram(position = "identity", alpha = 0.4, binwidth = 0.025)

plot(g_R_s_t1)

```

## Merge Choice Data

```{r merge}

df_t0 <- choice_t0 %>% 
  dplyr::select(i, d, t, m, f, x_1, x_2, x_3, x_4, price, prior_firm, choice)
df_t1 <- choice_t1 %>% 
  dplyr::select(i, d, t, m, f, x_1, x_2, x_3, x_4, price, prior_firm, choice, claims, score, R_s, R_C)

df <- dplyr::bind_rows(df_t0, df_t1) %>% 
  dplyr::arrange(t, i, d)

```

# Generate Data for Cost Model

[Later]

# Estimation

- Now we estimate the choice model, using data we generate
- Again, the choice model in the paper is as follows:

$$
\begin{align}
u_{idt}(C, s) &= u_{\gamma}(w_{it} + h_{idt}(C, s)) \\
h_{idt}(C, s) &= -p_{idt} - \mathbf{1}_{d, t-1} \cdot \psi_{idt} - e(C, y_{d}) - p_{idt} \cdot R_{idt}(C, s) \\
\text{where } \psi_{idt} &= \mathbf{1}_{d, t-1} \cdot \eta_{0} + \mathbf{1}_{f_{d}, t-1} \cdot \eta_{it} + \mathbf{1}_{m_{d}} \cdot \mathbf{1}_{t=0} \cdot \xi_{it}
\end{align}
$$

- At each period $t$, consumer $i$ chooses $d$ so as to maximize her expected utility:

$$
\begin{align}
d_{it} &= \mathop{\rm argmax}\limits_{d \in D_{it}} \left\{ v_{idt} + \varepsilon_{idt} \right\} \\
\text{where } v_{idt} &= \mathbb{E}_{C, s}[u_{idt}(C, s)] = \mathbb{E}[h_{idt}] -\frac{\gamma}{2}\mathbb{E}[h_{idt}^{2}]
\end{align}
$$

- We estimate the model by simulated maximum likelihood method. In doing so, we adopt a two-step estimation procedure since the cost model is easier to estimate but requires a large amount of data, while the demand model is making use of rich variations in choice but computationally demanding. 
- Therefore, we estimate risk and monitoring score parameters $(\theta_{\lambda}, \sigma_{\lambda}, \theta_{s}, \sigma_{s})$ first. 
- Then, we feed the estimates into the demand models as truth.

- The overall log likelihood function is expressed as follows:

$$
\begin{align}
    \mathscr{L}_{i} = \sum_{t \leq T_{i}} \int_{\lambda} \underbrace{\mathscr{L}(R_{it}, s_{i}, C_{it}, d_{it} \mid \lambda, \psi, x_{it}, p_{it}, D_{it}, d_{i, t-1} ; \Theta)}_{(A): \text{obs. stoc outcome}} \cdot \underbrace{g_{\lambda}(\lambda \mid x_{it} ; \theta_{\lambda}, \sigma_{\lambda})}_{(B): \text{latent var.}} d\lambda
\end{align}
$$

- We can decompose the likelihood component A as follows:

$$
\begin{align}
    (A) = & \ln \Pr(d_{it} \mid \lambda, x_{it}, p_{it}, D_{it}, d_{i, t-1}; a, \psi_{0}, \psi_{1}, \theta_{\eta}, \theta_{\xi}, \alpha, \theta_{\beta}) \notag \\
    & + \ln \Pr(C_{it} \mid \lambda, x_{it}) + \ln g(l_{it} \mid d_{it}, x_{it}; \alpha, \theta_{\beta}) \notag \\
    & + \ln g_{s}(s_{i} \mid \lambda, x_{it}; \theta_{s}, \sigma_{s}) + \ln g_{R}(R_{idt} \mid C_{it}, s_{i}, \lambda, x_{it}; \theta_{R}, \theta_{R, m}, \sigma_{R})
\end{align}
$$


## Fuctions

- To estimate the choice model, we write the following functions:
  - `gen_lambda` is a function that draws unobserved consumer risk $\lambda$. In this function, we draw $\lambda$ for $R$ times
  - `LL_choice` is a function that calculates choice probability that a consumer chooses each plan for each draw of $\lambda$
  - `LL_renewal_price` is a function that calculates choice probability that a consumer chooses each plan for each draw of $\lambda$
  - `SLL` is a function that calculates the simulated log-likelihood of consumer's choice. We maximize this fucntion to get the estimates of choice model parameters
- Note that when optimizing an objective function, it is important to keep the realizations of the shocks the same across the evaluations of the objective function. If the realization of the shocks differ across the objective function evaluations, the optimization algorithm will not converge because it cannot distinguish the change in the value of the objective function due to the difference in the parameters and the difference in the realized shocks
- To avoid this problem, we generate $\lambda$ outside the optimization algorithm


```{r function gen_lambda}

## Generate Lambda

gen_lambda <- function(df, cost_par, R){
  # Parameters
  theta_lambda <- cost_par[1:6]
  sigma_lambda <- cost_par[7]
  
  # Generate mu_lambda
  output <- df %>% 
    dplyr::mutate(mu_lambda = theta_lambda[1]
                  + theta_lambda[2]*x_1 + theta_lambda[3]*x_2
                  + theta_lambda[4]*x_3 + theta_lambda[5]*x_4
                  + theta_lambda[6]*ifelse(m == 1 & t == 0, 1, 0))
  
  # Generate epsilon_lambda (draw R times)
  epsilon_lambda <- matrix(rnorm(N * R, 0, sigma_lambda), nrow = N)
  colnames(epsilon_lambda) <- c(paste("lambda", 1:R, sep = "_"))
  
  epsilon_lambda <- data.frame(expand_grid(i = 1:N), epsilon_lambda) %>% 
    tibble::as_tibble()

  ## lambda
  output <- output %>%
    dplyr::left_join(epsilon_lambda, by = c("i")) %>%
    dplyr::mutate_at(.vars = vars(starts_with("lambda")),
                     .funs = ~ exp(mu_lambda + .)) %>% 
    dplyr::select(-mu_lambda)
 
  return(output)
}

# Calculate Choice Probability
cal_v <- function(df, theta, cost_par, R, lambda){
 # Parameters
  eta_f <- theta[1:4]
  xi <- theta[5:6]
  alpha_m0 <- theta[7:9]
  alpha_m1 <- theta[10:13]
  beta <- theta[14]
  risk_aversion <- theta[15]
  
  # Cost Parameters
  theta_score <- cost_par[8:11]
  sigma_score <- cost_par[12]
  l0 <- cost_par[13]
  a_l <- cost_par[14]
  
  ## Lambda
  lambda <- lambda
  
  # Price
  price <- df$price * matrix(rep(1, dim(df)[1] * R), nrow = dim(df)[1])
  colnames(price) <- c(paste("price", 1:R, sep = "_"))
  
  price <- data.frame(price) %>% 
    tibble::as_tibble()  
  
  # Generate Demand Friction
  demand_friction <- lambda %>% 
    dplyr::mutate_at(vars(starts_with("lambda")),
                     funs(ifelse(d == prior_firm, 
                                 0,  
                                 eta_f[1] + eta_f[2]*x_1 + eta_f[3]*x_2 + eta_f[4]*x_3) 
                          + ifelse(d == 1 & t == 0, 
                                   xi[1] + xi[2]*log(.), 
                                   0))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "lambda", "demand_friction"), 
                       starts_with("lambda")) %>% 
    dplyr::select(matches("demand_friction"))
  
  # Generate E_score
  E_score <- lambda %>% 
    dplyr::mutate_at(vars(starts_with("lambda")),
                     funs(ifelse(t == 0 & m == 1,
                                 exp(theta_score[1] + theta_score[2]*log(.)
                                     + theta_score[3]*x_1 + theta_score[4]*x_2
                                     + sigma_score^2 / 2),
                                 0))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "lambda", "E_score"), 
                       starts_with("lambda"))
  
  # Generate E_oop
  E_oop <- lambda %>% 
    dplyr::mutate_at(vars(starts_with("lambda")),
                     funs(.*exp(-.)*(l0^(a_l)/(a_l - 1))*policy_limit^(-a_l + 1))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "lambda", "E_oop"), 
                       starts_with("lambda")) %>% 
    dplyr::select(matches("E_oop"))
  
  # Generate E_oop_sq
  E_oop_sq <- lambda %>% 
    dplyr::mutate_at(vars(starts_with("lambda")),
                     funs(.*exp(-.)*((2 * l0^(a_l)) / ((a_l - 1) * (a_l - 1))) * policy_limit^(-a_l + 2))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "lambda", "E_oop_sq"), 
                       starts_with("lambda")) %>% 
    dplyr::select(matches("E_oop_sq"))

  # Generate E_R_s
  E_R_s <- E_score %>% 
    dplyr::mutate_at(vars(starts_with("E_score")),
                     funs(ifelse(t == 0 & m == 1,
                                 (alpha_m1[1] + alpha_m1[2]*x_1 + alpha_m1[3]*x_2 + alpha_m1[4]*.) / beta,
                                 (alpha_m0[1] + alpha_m0[2]*x_1 + alpha_m0[3]*x_2) / beta))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "E_score", "E_R_s"), 
                       starts_with("E_score")) %>% 
    dplyr::select(matches("E_R_s"))

  # Generate E_R_s_sq
  E_R_s_sq <- E_score %>% 
    dplyr::mutate_at(vars(starts_with("E_score")),
                     funs(ifelse(t == 0 & m == 1,
                                 (alpha_m1[1] + alpha_m1[2]*x_1 + alpha_m1[3]*x_2 + alpha_m1[4]*.) / beta^2,
                                 (alpha_m0[1] + alpha_m0[2]*x_1 + alpha_m0[3]*x_2) / beta^2))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "E_score", "E_R_s_sq"), 
                       starts_with("E_score")) %>% 
    dplyr::select(matches("E_R_s_sq"))  
  
  # Generate E_R_C
  E_R_C <- lambda %>% 
    dplyr::mutate_at(vars(starts_with("lambda")),
                     funs(0.98 * exp(-.) + 1.2 * (1 - exp(-.)))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "lambda", "E_R_C"), 
                       starts_with("lambda")) %>% 
    dplyr::select(matches("E_R_C"))

  # Generate E_R_C_sq
  E_R_C_sq <- lambda %>% 
    dplyr::mutate_at(vars(starts_with("lambda")),
                     funs(0.98^2 * exp(-.) + 1.2^2 * (1 - exp(-.)))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "lambda", "E_R_C_sq"), 
                       starts_with("lambda")) %>% 
    dplyr::select(matches("E_R_C_sq"))
  
  # Calculate E_h
  E_h <- - price - demand_friction - E_oop - E_R_s * E_R_C * price
  E_h <- E_h %>% 
    dplyr::rename_with(\(x) str_replace(x, "price", "E_h"), 
                       starts_with("price"))
  
  # Calculate E_h_sq
  E_h_sq <- price^2 + demand_friction^2 + E_oop_sq + E_R_s_sq*E_R_C_sq*price^2
  + 2*price*demand_friction + 2*price*E_oop + 2*price*(E_R_s*E_R_C*price)
  + 2*demand_friction*E_oop + 2*demand_friction*(E_R_s*E_R_C*price)
  + 2*E_oop*(E_R_s*E_R_C*price)
    
  E_h_sq <- E_h_sq %>% 
    dplyr::rename_with(\(x) str_replace(x, "price", "E_h_sq"), 
                       starts_with("price"))
  
  # Calculate v
  v <- (E_h - (risk_aversion / 2) * E_h_sq) %>% 
    dplyr::rename_with(\(x) str_replace(x, "E_h", "v"), 
                       starts_with("E_h"))
  
  output <- df %>% 
    dplyr::bind_cols(v)
  
  return(output)
}
    
cal_choice_probability <- function(df, theta, cost_par, R, lambda){
  ## Calculate v
  v <- cal_v(df, theta, cost_par, R, lambda)
  
  ## Calculate Choice Probability
  output <- v %>% 
    dplyr::group_by(i, t) %>% 
    dplyr::mutate_at(vars(starts_with("v")),
                     funs(exp(.) / sum(exp(.)))) %>% 
    dplyr::ungroup() %>% 
    dplyr::rename_with(\(x) str_replace(x, "v", "choice_probability"), 
                       starts_with("v")) 
}


# Log-likelihood for Choice Probability

LL_choice <- function(df, theta, cost_par, R, lambda){
  ## Calculate Choice Probability
  choice_probability <- cal_choice_probability(df, theta, cost_par, R, lambda)
  
  ## Calculate Log-likelihood
  LL_choice <- choice_probability %>% 
    dplyr::mutate_at(vars(starts_with("choice_probability")),
                     funs(choice * log(.))) %>% 
    dplyr::summarise_at(vars(starts_with("choice_probability")),
                        funs(sum(.)))
  
  LL_choice <- as.matrix(LL_choice) %>% 
    apply(1, mean)
  
  # Output
  output <- LL_choice

  return(output)
}

# Log-likelihood for Renewal Price

LL_renewal_price <- function(df, theta, cost_par, lambda){
  # Parameters
  alpha_m0 <- theta[7:9]
  alpha_m1 <- theta[10:13]
  beta <- theta[14]
  
  # Generate log-likelihood of R_s
  ## In the paper, we assume away uncertainty in s
  R_s <- df %>% 
    dplyr::filter(t == 1) %>% 
    dplyr::mutate(gamma_alpha = ifelse(score == 1,
                                       alpha_m0[1] + alpha_m0[2]*x_1 + alpha_m0[3]*x_2,
                                       alpha_m1[1] + alpha_m1[2]*x_1 + alpha_m1[3]*x_2 + alpha_m1[4]*score),
                  LL_gamma = log(((beta^gamma_alpha)/gamma(gamma_alpha)) * R_s^(gamma_alpha - 1) * exp(-beta * R_s)))
  
  LL_R_s <- sum(R_s$LL_gamma)
  
  ## 作ったが、Choice Modelの推定においては不要
  # Generate log-likelihood of R_C
  ## We first match lambda in t = 0, since claim surcharge is resulted from lambda in t = 0
  
  # lambda_t0 <- lambda %>% 
  #   dplyr::filter(t == 0, f == 1) %>% 
  #   dplyr::select(i, m, matches("lambda"))
  # 
  # R_C <- df %>% 
  #   dplyr::filter(t == 1) %>% 
  #   dplyr::mutate(m = ifelse(score == 1, 0, 1)) %>% 
  #   dplyr::left_join(lambda_t0, by = c("i", "m")) %>% 
  #   dplyr::mutate_at(vars(starts_with("lambda")),
  #                    funs((exp(-.)^(R_C == 0.98)) * (1 - exp(-.)^(R_C == 1.2)))) %>% 
  #   dplyr::rename_with(\(x) str_replace(x, "lambda", "LL_surcharge"), 
  #                      starts_with("lambda")) %>% 
  #   dplyr::summarise_at(vars(starts_with("LL_surcharge")),
  #                       funs(sum(.)))
  # 
  # LL_R_C <- as.matrix(R_C) %>% 
  #   apply(1, mean)
  
  output <- LL_R_s
  
  return(output)
}


## Simulated Log-likelihood

SLL <- function(df, theta, cost_par, R, lambda){
  ## Choice Probability
  LL_choice <- LL_choice(df, theta, cost_par, R, lambda)
  
  ## Renewal Price
  LL_renewal_price <- LL_renewal_price(df, theta, cost_par, lambda)
  
  ## Output
  output <- (-1) * (LL_choice + LL_renewal_price)
  print(output)
  
  return(output)
}

```

## Optimization

```{r optimization}
# Cost Parameters
cost_par <- 0
cost_par[1:6] <- theta_lambda
cost_par[7] <- sigma_lambda
cost_par[8:11] <- theta_score
cost_par[12] <- sigma_score
cost_par[13] <- l0
cost_par[14] <- a_l

# Choice Parameters
theta <- 0
theta[1:4] <- eta_f
theta[5:6] <- xi
theta[7:9] <- alpha_m0
theta[10:13] <- alpha_m1
theta[14] <- beta
theta[15] <- risk_aversion

# Generate lambda
R <- 50
lambda <- gen_lambda(df, cost_par, R)

## Initial Value
# x0 <- rep(1, length(theta))
# x0[7] <- 20
# x0[10] <- 20
# x0[14] <- 20
# x0[15] <- 0

x0 <- numeric(length(theta))
x0[7] <- 1
x0[10] <- 1
x0[14] <- 1

x0 <- theta

## Optimization
res <- optim(par = x0,
             fn = SLL, 
             control = list(maxit = 10^6),
             method = "Nelder-Mead",
             df = df, 
             cost_par = cost_par, 
             R = R,
             lambda = lambda)
  
theta_est <- res$par

```

## Estimation Results

```{r estimation results}

table <- cbind(theta, theta_est)
table <- format(round(table, 3), 3)

colnames(table) <- c("true", "estimates")
rownames(table) <- c("eta_f", "", "", "", 
                     "xi", "", 
                     "alpha_m0", "", "", "", 
                     "alpha_m1", "", "", 
                     "beta",
                     "risk_aversion")
table

```


# Counterfactual Simulation

## Welfare Calculation

Using our demand estimates, we evaluate the impact that the monitoring program has on consumer welfare and on firm profits in the status quo. To do this, we simulate a counterfactual scenario in which monitoring is not available, and compare it to the status quo baseline with monitoring.

1. For each driver $i$, simulate random coefficients (private risk) $L \in \mathbb{N}^{+}$ times
2. For each draw $l \in \{ 1, ..., L \}$, calculate ex-ante utility directly and the corresponding certainty equivalent. First-period choice probabilities are also calculated, which gives us the monitoring share. Expected cost of the first semester can be calculated directly. But we also need to form an expectation of the second-period cost (and prices) in order to calculate total surplus (and profit):
3. Simulate $K \in \mathbb{N}^{+}$ draws of first-period claim occurrence and monitoring score based on private risk . Each draw pins down the renewal price change that driver $i$ would face in the second period. All other prices remain constant. For each first-period choice $d$, we can then calculate the second period choice probability and the corresponding expected cost

```{r welfare calculation}
# Number of Draws
L <- 100
K <- 50

## df for t = 0
df_t0 <- df %>% 
  dplyr::filter(t == 0)

## Simulate Private Risk Lambda
sim_lambda <- gen_lambda(df_t0, cost_par, L)

## Calculate Certainty Equivalent for Each Draw
### theta_estを入れるのが正しいが挙動確認のためthetaを入れている
cal_certainty_equivalent <- function(df, theta, cost_par, R, lambda){
  ## Risk Aversion
  risk_aversion <- theta[15]
  
  ## Calculate CE
  ### We apply `cal_v` to obtain v
  output <- cal_v(df, theta, cost_par, R, lambda) %>% 
    dplyr::mutate_at(vars(starts_with("v")),
                     funs(1 / risk_aversion - sqrt((1 / risk_aversion^2) - 2*. / risk_aversion))) %>% 
    dplyr::rename_with(\(x) str_replace(x, "v", "certatinty_equivalent"), 
                       starts_with("v"))

  return(output)
}

sim_renewal_price <- function(df, theta, cost_par, R, lambda){
  ## Generate Claims
  lambda_mat <- lambda %>% 
    dplyr::select(starts_with("lambda")) %>% 
    as.matrix()
  
  claims <- matrix(rpois(dim(df)[1]*L*K, lambda = lambda_mat), nrow = dim(df)[1])
  colnames(claims) <- paste("claims", 1:(L*K), sep = "_")
  
  claims <- data.frame(claims) %>% 
    tibble::as_tibble()  
  
  ## Generate Monitoring Score
  theta_score <- cost_par[8:11]
  sigma_score <- cost_par[12]

  mu_score <- lambda %>%
    dplyr::mutate_at(vars(starts_with("lambda")),
                     funs(theta_score[1] + theta_score[2]*log(.)
                          + theta_score[3]*x_1 + theta_score[4]*x_2)) %>%
    dplyr::rename_with(\(x) str_replace(x, "lambda", "mu_score"),
                       starts_with("lambda")) %>%
    dplyr::select(starts_with("mu_score")) %>%
    as.matrix()
  
  score <- matrix(rlnorm(dim(df)[1]*L*K, mu_score, sigma_score), nrow = dim(df)[1])
  colnames(score) <- paste("score", 1:(L*K), sep = "_")

  score <- data.frame(score) %>%
    tibble::as_tibble()
  
  ## Calculate Claim Surcharge R_C
  R_C <- claims %>% 
    dplyr::mutate_at(vars(starts_with("claims")),
                     funs(ifelse(. == 0, 0.98, 1.2))) %>%
    dplyr::rename_with(\(x) str_replace(x, "claims", "R_C"),
                       starts_with("claims"))

  ## Calculate Base R_s
  ### Note that, for simplicity, assume that R0 is deterministic conditional on s. In reality, the spread of baseline R0 without monitoring may have subtle nonlinear effects on consumer choice, which we assume away
  alpha_m0 <- theta[7:9]
  alpha_m1 <- theta[10:13]
  beta <- theta[14]
  
  R_s <- df %>% 
    dplyr::select(m, x_1, x_2) %>% 
    dplyr::bind_cols(score) %>% 
    dplyr::mutate_at(vars(starts_with("score")),
                     funs(ifelse(m == 0,
                                 (alpha_m0[1] + alpha_m0[2]*x_1 + alpha_m0[3]*x_2) / beta,
                                 (alpha_m1[1] + alpha_m1[2]*x_1 + alpha_m1[3]*x_2 + alpha_m1[4]*.) / beta))) %>%
    dplyr::rename_with(\(x) str_replace(x, "score", "R_s"),
                       starts_with("score")) %>% 
      dplyr::select(-c(m, x_1, x_2))
  
  ## Calculate Base Renewal Price
  price <- df$price * matrix(rep(1, dim(df)[1] * L * K), nrow = dim(df)[1])
  colnames(price) <- c(paste("price", 1:(L * K), sep = "_"))
  
  price <- data.frame(price) %>% 
    tibble::as_tibble()
  
  output <- price * R_C * R_s
  
  return(output)
}

tmp_score <- sim_renewal_price(df_t0, theta, cost_par, R, sim_lambda)

```
